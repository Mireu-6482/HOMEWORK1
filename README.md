## 1-1

변수 a 선언


## 1-2

변수 a에 string abc 할당 

번수 선언후 할당, 선언과 할당을 한 문장에 표현은 같은 동작을 수행한다.

## 1-3

변수 선언, 문자열 연결, 값 변경을 보여주는 코드

## 1-4

obj1 이라는 숫자와 문자열 속성을 가진 간단한 객체 생성

## 1-5

객체의 속성 값을 점 표기법 obj1.a 을 사용해 수정한 간단한 예제

## 1-6

객체 안에 배열을 포함한 구조

## 1-7

기본 자료형과 객체의 복사 방식 차이

## 1-8

기본형과 참조형 데이터의 동작 차이

## 1-9

기본형 값 복사, 객체 참조, 그리고 객체의 참조 변경

## 1-10

객체의 참조 방식과 함수 내에서 객체를 수정할 때 발생하는 영향을 보여줌

## 1-11

객체를 새로 만들어 반환하여, 원본 객체를 변경하지 않고 복사하는 방식

## 1-12

객체를 얕은복사하는 예제

## 1-13

객체를 복사한 후, 복사된 객체를 수정해도 원본에 영향이 없다는 것을 보여주는 예제

## 1-14

얕은 복사의 한계를 보여주는 예제로, 겉보기에는 객체를 복사했지만, 내부 객체는 여전히 원본과 연결되어 있다는 것을 보여주는 예제

## 1-15

중첩된 객체도 복사하는 예제

## 1-16

객체를 재귀적으로 깊은복사 하기 위한 함수
객체 안에 또다른 객체가 있어도 모든 계층을 복사해서 원본과 완전히 독립적인 복사본을 만들어줌

## 1-17

깊은복사를 했던 함수에 대한 결과를 보여주는 예제

## 1-18

JSON 방식을 사용하여 간단한 깊은 복사 방법을 보여주는 예제

## 1-19

값을 대입하지 않은 변수에 접근을 하게 하고, 존재 하지 않는 프로퍼티에 접근하게 하여 return 값이 없어가지고 자동으로 undefined로 정의되는 예제

## 1-20

배열의 길이와 요소의 정의 상태가 배열 내부에 어떤 차이를 만드는지 보여주는 예제
empty와 undefined의 차이를 구별해주는것이 중요

## 1-21

이 코드는 JavaScript 배열에서 undefined 값이 명시적으로 있는 경우와 empty인 경우가 어떻게 다르게 동작하는지를 forEach, map, filter, reduce를 통해 비교한 것

## 1-22

null과 undefined의 비교 및 타입 확인에 대한 중요한 차이를 설명하는 예제
null : 의도적으로 없음, undefinde : 할당되지 않음

## 2-1

스코프(scope) 와 호이스팅(hoisting) 개념을 보여주는 예제
var는 선언만 호이스팅 되고 값 할당은 그대로 남음

## 2-2

변수 호이스팅, 함수 매개변수, 그리고 var의 중복 선언이 어떻게 처리되는지 보여주는 예제

## 2-3

var 변수 선언의 호이스팅과 중복 선언이 어떻게 처리되는지를 보여주는 예제

## 2-4

var 키워드로 동일한 이름의 변수를 여러 번 선언했을 때 어떻게 처리되는지를 보여주는 예제

## 2-5

변수와 함수 선언의 호이스팅 순서, 특히 var와 함수 선언식의 충돌이 어떻게 처리되는지를 보여주는 예제

## 2-6

호이스팅동작, 특히 동일한 이름을 가진 함수 선언과 변수 선언이 충돌할 경우의 우선순위를 보여주는 예제

## 2-7

함수선언문을 함수 표현식으로 바꾸었을 경우에 어떻게 동작하는이 보여주는 예제

## 2-8

함수를 정의하는 세가지 방식에 대해서 설명하는 예제

## 2-9

함수선언문과 함수 표현식의 호이스팅 차이를 보여주는 예제

## 2-10

함수 표현식과 변수 선언의 호이스팅 차이를 설명하는 예제

## 2-11

동일한 함수 이름의 중복 선언 시, 마지막 선언이 이전 선언을 덮는다는 것을 보여주는 예제

## 2-12

함수 표현식은 호이스팅되지 않기 때문에, 선언 전에 사용할 수 없다는 점을 설명하는 예제

## 2-13

변수 호이스팅으로 인해, 같은 이름의 변수라도 스코프 내에서 다르게 동작할 수 있음을 설명하는 예제

## 2-14

함수 객체 내부의 정보(스코프 체인, name 등)를 console.dir로 확인하는 예제

## 2-15

함수가 자신이 정의된 렉시컬 환경의 변수에 접근할 수 있다는 클로저의 개념을 보여주는 예제

## 2-16

디버거와 함께 렉시컬 스코프 안에서 변수 참조를 추적하는 데모 예제

## 3-1

브라우저 환경에서 this는 전역 객체 window를 참조함을 보여주는 예제

## 3-2

Node.js 환경에서 this는 전역 객체 global을 참조함을 보여주는 예제

## 3-3

전역 변수는 전역 객체의 프로퍼티가 된다는 것을 설명하는 예제

## 3-4

전역 변수와 전역 객체의 관계, 그리고 변수 재할당의 전파를 보여주는 예제

## 3-5

delete 연산자가 변수와 전역 객체의 프로퍼티에 다르게 작동함을 설명하는 예제

## 3-6

함수의 호출 방식에 따라 this가 달라지는 것을 보여주는 예제
일반 호출과 매서드 호출 둘을 비교하고 있다

## 3-7

객체의 메서드를 점 표기법과 대괄호 표기법으로 호출해도 this는 동일함을 보여주는 예제

## 3-8

객체 내부 구조가 달라도 메서드를 호출한 주체에 따라 this가 결정된다는 것을 설명하는 예제

## 3-9

메서드 안에서 정의된 일반 함수는 this가 전역 객체로 바인딩된다는 것을 설명하는 예제

## 3-10

this를 우회 참조하기 위해 self를 저장해 사용하는 대표적인 클로저 패턴을 설명하는 예제

## 3-11

화살표 함수는 외부 스코프의 this를 그대로 참조한다는 것을 설명하는 예제

## 3-12

일반 함수의 호출 방식에 따라 this가 다르게 바인딩됨을 보여주는 예제

## 3-13

생성자 함수로 객체를 생성할 때 this가 인스턴스를 가리킴을 설명하는 예제

## 3-14

call 메서드를 사용해 함수 호출 시 this를 명시적으로 지정하는 방법을 설명하는 예제

## 3-15

call을 통해 메서드 호출 시에도 this를 다른 객체로 바꿔 쓸 수 있음을 보여주는 예제

## 3-16

apply 메서드를 사용해 배열 형태로 인수를 전달하면서 this를 지정하는 예제

## 3-17

배열 메서드를 call로 유사 배열 객체에 적용하는 방법을 설명하는 예제

## 3-18

유사 배열 객체나 arguments를 실제 배열로 변환하는 방법을 설명하는 예제

## 3-19

문자열 같은 유사 배열에 배열 메서드를 call, apply로 적용할 수 있음을 보여주는 예제

## 3-20

Array.from()을 이용해 유사 배열 객체를 간편하게 배열로 변환하는 예제

## 3-21

call과 apply를 사용해 부모 생성자 함수를 상속하는 방식(생성자 상속)을 설명하는 예제

## 3-22

배열의 최대값/최소값을 순회하며 수동으로 찾는 방법을 보여주는 예제

## 3-23

Math.max / Math.min에 apply를 사용해 배열에서 최대/최솟값을 구하는 예제

## 3-24

ES6의 전개 연산자 '...' 를 사용해 배열을 Math.max 등에 직접 전달하는 방법을 보여주는 예제

## 3-25

bind 메서드로 this를 영구 고정하고, 일부 인수를 미리 지정하는 부분 적용예제

## 3-26

bind된 함수의 name 속성이 bound originalName 형식으로 바뀐다는 것을 설명하는 예제

## 3-27

call과 bind를 통해 내부 함수의 this를 외부 스코프와 일치시키는 방법을 설명하는 예제

## 3-28

setTimeout 안에서 this가 전역 객체가 되지만, bind를 쓰면 원래 객체를 유지할 수 있음을 보여주는 예제

## 3-29

화살표 함수는 상위 컨텍스트의 this를 유지함으로써 bind 없이도 객체 내부에서 원하는 this를 쓸 수 있음을 설명하는 예제

## 3-30

배열 메서드의 thisArg 두 번째 인자를 이용해 콜백 내에서 this 바인딩을 유지하는 예제

## 3-31

배열 및 컬렉션 메서드들에 thisArg를 넘길 수 있다는 사실을 명세로 요약한 예시

