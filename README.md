## 1-1

변수 a 선언


## 1-2

변수 a에 string abc 할당 

번수 선언후 할당, 선언과 할당을 한 문장에 표현은 같은 동작을 수행한다.

## 1-3

변수 선언, 문자열 연결, 값 변경을 보여주는 코드

## 1-4

obj1 이라는 숫자와 문자열 속성을 가진 간단한 객체 생성

## 1-5

객체의 속성 값을 점 표기법 obj1.a 을 사용해 수정한 간단한 예제

## 1-6

객체 안에 배열을 포함한 구조

## 1-7

기본 자료형과 객체의 복사 방식 차이

## 1-8

기본형과 참조형 데이터의 동작 차이

## 1-9

기본형 값 복사, 객체 참조, 그리고 객체의 참조 변경

## 1-10

객체의 참조 방식과 함수 내에서 객체를 수정할 때 발생하는 영향을 보여줌

## 1-11

객체를 새로 만들어 반환하여, 원본 객체를 변경하지 않고 복사하는 방식

## 1-12

객체를 얕은복사하는 예제

## 1-13

객체를 복사한 후, 복사된 객체를 수정해도 원본에 영향이 없다는 것을 보여주는 예제

## 1-14

얕은 복사의 한계를 보여주는 예제로, 겉보기에는 객체를 복사했지만, 내부 객체는 여전히 원본과 연결되어 있다는 것을 보여주는 예제

## 1-15

중첩된 객체도 복사하는 예제

## 1-16

객체를 재귀적으로 깊은복사 하기 위한 함수
객체 안에 또다른 객체가 있어도 모든 계층을 복사해서 원본과 완전히 독립적인 복사본을 만들어줌

## 1-17

깊은복사를 했던 함수에 대한 결과를 보여주는 예제

## 1-18

JSON 방식을 사용하여 간단한 깊은 복사 방법을 보여주는 예제

## 1-19

값을 대입하지 않은 변수에 접근을 하게 하고, 존재 하지 않는 프로퍼티에 접근하게 하여 return 값이 없어가지고 자동으로 undefined로 정의되는 예제

## 1-20

배열의 길이와 요소의 정의 상태가 배열 내부에 어떤 차이를 만드는지 보여주는 예제
empty와 undefined의 차이를 구별해주는것이 중요

## 1-21

이 코드는 JavaScript 배열에서 undefined 값이 명시적으로 있는 경우와 empty인 경우가 어떻게 다르게 동작하는지를 forEach, map, filter, reduce를 통해 비교한 것

## 1-22

null과 undefined의 비교 및 타입 확인에 대한 중요한 차이를 설명하는 예제
null : 의도적으로 없음, undefinde : 할당되지 않음

## 2-1

스코프(scope) 와 호이스팅(hoisting) 개념을 보여주는 예제
var는 선언만 호이스팅 되고 값 할당은 그대로 남음

## 2-2

변수 호이스팅, 함수 매개변수, 그리고 var의 중복 선언이 어떻게 처리되는지 보여주는 예제

## 2-3

var 변수 선언의 호이스팅과 중복 선언이 어떻게 처리되는지를 보여주는 예제

## 2-4

var 키워드로 동일한 이름의 변수를 여러 번 선언했을 때 어떻게 처리되는지를 보여주는 예제

## 2-5

변수와 함수 선언의 호이스팅 순서, 특히 var와 함수 선언식의 충돌이 어떻게 처리되는지를 보여주는 예제

## 2-6

호이스팅동작, 특히 동일한 이름을 가진 함수 선언과 변수 선언이 충돌할 경우의 우선순위를 보여주는 예제

## 2-7

함수선언문을 함수 표현식으로 바꾸었을 경우에 어떻게 동작하는이 보여주는 예제

## 2-8

함수를 정의하는 세가지 방식에 대해서 설명하는 예제

## 2-9

함수선언문과 함수 표현식의 호이스팅 차이를 보여주는 예제

## 2-10

함수 표현식과 변수 선언의 호이스팅 차이를 설명하는 예제

## 2-11

동일한 함수 이름의 중복 선언 시, 마지막 선언이 이전 선언을 덮는다는 것을 보여주는 예제

## 2-12

함수 표현식은 호이스팅되지 않기 때문에, 선언 전에 사용할 수 없다는 점을 설명하는 예제

## 2-13

변수 호이스팅으로 인해, 같은 이름의 변수라도 스코프 내에서 다르게 동작할 수 있음을 설명하는 예제

## 2-14

함수 객체 내부의 정보(스코프 체인, name 등)를 console.dir로 확인하는 예제

## 2-15

함수가 자신이 정의된 렉시컬 환경의 변수에 접근할 수 있다는 클로저의 개념을 보여주는 예제

## 2-16

디버거와 함께 렉시컬 스코프 안에서 변수 참조를 추적하는 데모 예제

## 3-1

브라우저 환경에서 this는 전역 객체 window를 참조함을 보여주는 예제

## 3-2

Node.js 환경에서 this는 전역 객체 global을 참조함을 보여주는 예제

## 3-3

전역 변수는 전역 객체의 프로퍼티가 된다는 것을 설명하는 예제

## 3-4

전역 변수와 전역 객체의 관계, 그리고 변수 재할당의 전파를 보여주는 예제

## 3-5

delete 연산자가 변수와 전역 객체의 프로퍼티에 다르게 작동함을 설명하는 예제

## 3-6

함수의 호출 방식에 따라 this가 달라지는 것을 보여주는 예제
일반 호출과 매서드 호출 둘을 비교하고 있다

## 3-7

객체의 메서드를 점 표기법과 대괄호 표기법으로 호출해도 this는 동일함을 보여주는 예제

## 3-8

객체 내부 구조가 달라도 메서드를 호출한 주체에 따라 this가 결정된다는 것을 설명하는 예제

## 3-9

메서드 안에서 정의된 일반 함수는 this가 전역 객체로 바인딩된다는 것을 설명하는 예제

## 3-10

this를 우회 참조하기 위해 self를 저장해 사용하는 대표적인 클로저 패턴을 설명하는 예제

## 3-11

화살표 함수는 외부 스코프의 this를 그대로 참조한다는 것을 설명하는 예제

## 3-12

일반 함수의 호출 방식에 따라 this가 다르게 바인딩됨을 보여주는 예제

## 3-13

생성자 함수로 객체를 생성할 때 this가 인스턴스를 가리킴을 설명하는 예제

## 3-14

call 메서드를 사용해 함수 호출 시 this를 명시적으로 지정하는 방법을 설명하는 예제

## 3-15

call을 통해 메서드 호출 시에도 this를 다른 객체로 바꿔 쓸 수 있음을 보여주는 예제

## 3-16

apply 메서드를 사용해 배열 형태로 인수를 전달하면서 this를 지정하는 예제

## 3-17

배열 메서드를 call로 유사 배열 객체에 적용하는 방법을 설명하는 예제

## 3-18

유사 배열 객체나 arguments를 실제 배열로 변환하는 방법을 설명하는 예제

## 3-19

문자열 같은 유사 배열에 배열 메서드를 call, apply로 적용할 수 있음을 보여주는 예제

## 3-20

Array.from()을 이용해 유사 배열 객체를 간편하게 배열로 변환하는 예제

## 3-21

call과 apply를 사용해 부모 생성자 함수를 상속하는 방식(생성자 상속)을 설명하는 예제

## 3-22

배열의 최대값/최소값을 순회하며 수동으로 찾는 방법을 보여주는 예제

## 3-23

Math.max / Math.min에 apply를 사용해 배열에서 최대/최솟값을 구하는 예제

## 3-24

ES6의 전개 연산자 '...' 를 사용해 배열을 Math.max 등에 직접 전달하는 방법을 보여주는 예제

## 3-25

bind 메서드로 this를 영구 고정하고, 일부 인수를 미리 지정하는 부분 적용예제

## 3-26

bind된 함수의 name 속성이 bound originalName 형식으로 바뀐다는 것을 설명하는 예제

## 3-27

call과 bind를 통해 내부 함수의 this를 외부 스코프와 일치시키는 방법을 설명하는 예제

## 3-28

setTimeout 안에서 this가 전역 객체가 되지만, bind를 쓰면 원래 객체를 유지할 수 있음을 보여주는 예제

## 3-29

화살표 함수는 상위 컨텍스트의 this를 유지함으로써 bind 없이도 객체 내부에서 원하는 this를 쓸 수 있음을 설명하는 예제

## 3-30

배열 메서드의 thisArg 두 번째 인자를 이용해 콜백 내에서 this 바인딩을 유지하는 예제

## 3-31

배열 및 컬렉션 메서드들에 thisArg를 넘길 수 있다는 사실을 명세로 요약한 예시

## 4-1

setInterval 과 clearInterval을 이용한 반복 타이머 제어 예제

## 4-2

콜백 함수를 별도로 정의하여 타이머 함수로 재사용 하는 예제

## 4-3

Array.prototype.map()의 기본 동작 방식(값과 인덱스 순서)을 보여주는 예제

## 4-4

map()의 콜백 파라미터 순서를 잘못 지정했을 때 발생하는 실수를 설명하는 예제

## 4-5

사용자 정의로 map() 메서드를 구현하여 내부 작동 원리를 설명하는 예제

## 4-6

일반 함수에서의 this 바인딩이 상황마다 어떻게 달라지는 지를 설명하는 예제

## 4-7

메서드를 콜백으로 직접 넘겼을 때 this가 달라지는 현상을 설명하는 예제

## 4-8

this를 잃지 않기 위해 self 변수에 참조를 저장하는 고전적인 우회 패턴을 설명하는 예제

## 4-9

객체의 메서드를 setTimeout에 넘길 때 this가 변경된다는 현상을 보여주는 예제

## 4-10

동일한 함수 참조를 다른 객체에서 실행할 때 this가 어떻게 바뀌는지 설명하는 예제

## 4-11

bind()를 사용하여 this를 고정시키는 방식의 안전한 비동기 처리 예제

## 4-12

중첩된 setTimeout으로 콜백 지옥(callback hell)을 표현한 대표적인 구조 예제

## 4-13

중첩대신 함수 분리로 콜백 지옥을 구조적으로 개선한 예제

## 4-14

promise 체이닝을 통해 비동기 흐름을 가독성 있게 표현하는 예제

## 4-15

고차 함수를 이용해 promise 흐름을 더욱 재사용 가능하게 만든 예제

## 4-16

generator 함수를 활용한 비동기 흐름 제어 패턴을 설명하는 예제

## 4-17

async/await를 이용해 가장 간결하게 비동기 로직을 표현한 예제

## 5-1

중첩 함수 내부에서 외부 변수에 접근하여 값을 변경하는 기본적인 클로저 구조

## 5-2

함수 실행 결과를 바로 반환하면서 클로저처럼 동작시키는 예제

## 5-3

함수를 반환하여 반환된 함수가 오부 변수에 지속적으로 접근하는 클로저 예제

## 5-4

setInterval 과 이벤트 리스너를 통해 클로저가 생성되는 상황을 보여주는 예제

## 5-5

클로저로 인한 메모리 점유를 해제하는 패턴(return, clearInterval, removeEventListener) 예제

## 5-6

클로저로 각 리스트 항목마다 고유한 fruit 값을 유지하는 예제

## 5-7

이벤트 리스너에 같은 함수 참조를 쓰면 각 항목마다 값이 달라지지 않는 문제를 설명하는 예제

## 5-8

bind()를 이용해 클로저처럼 동작하게 만들어 항목별 고유 동작을 구현하는 예제

## 5-9

고차 함수를 사용해 고유한 클로저를 반환하여 각 항목마다 독립적인 리스너를 만드는 예제

## 5-10

객체 메서드를 이용해 상태(fuel, moved)를 관리하는 캡슐화된 자동차 시뮬레이션

## 5-11

getter를 활용해 클로저 기반으로 내부 상태를 보오하면서 조작하는 구조

## 5-12

Object.freeze()를 이용해 반환된 객체의 외부 변경을 방지하는 불변 객체 생성 예제

## 5-13

bind()를 사용해 다수의 인자를 미리 고정한 부분 적용 함수 구현

## 5-14

사용자 정의 partial() 함수로 부분 적용을 구현하고 this 바인딩 활용도 함께 설명

## 5-15

특수 기호 _를 활용해 자리 지정이 가능한 고급 partial 함수 구현

## 5-16

이벤트를 제한적으로 실행하기 위한 debounce 함수 구현

## 5-17

함수를 한 인자씩 나눠 실행 가능한 커링 함수 예제

## 5-18

다단계 커링을 통해 다수 인자를 순차적으로 전달할 수 있는 함수 구현